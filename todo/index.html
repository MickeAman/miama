<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>att göra</title>

  <!-- pwa / ikoner (frivilligt) -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <meta name="theme-color" content="#f7f7f5">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="att göra">
  <link rel="apple-touch-icon" href="icon-512.png">

  <!-- react + babel + tailwind + nosleep -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/nosleep.js@0.12.0/dist/NoSleep.min.js"></script>

  <style>
    body{background:#f7f7f5;color:#1a1a1a;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;-webkit-tap-highlight-color:transparent}
    input:focus,button:focus{outline:none}
    .icon-btn{background:transparent;border:0;cursor:pointer;color:#9ca3af;padding:.25rem}
    .icon-btn:hover{color:#4b5563}
    .input-clear{position:absolute;right:.5rem;top:50%;transform:translateY(-50%);background:transparent;border:0;color:#9ca3af}
    .input-clear:hover{color:#4b5563}
    .plus-wrap{display:flex;flex-direction:column;align-items:center;gap:.25rem}
    .plus-btn{display:flex;align-items:center;justify-content:center;width:56px;height:56px;border-radius:14px;background:#f3f4f6;color:#6b7280;font-size:36px;font-weight:200;transition:color .2s,transform .1s,background .2s;user-select:none;-webkit-user-select:none}
    .plus-btn:hover{color:#1f2937;background:#e5e7eb}
    .plus-btn:active{transform:scale(.97)}
    .glow{box-shadow:0 0 0 3px rgba(45,45,45,.08) inset,0 0 0 2px #a3a3a3;border-radius:8px}
    @keyframes fadeSlideIn{0%{opacity:0;transform:translateY(6px) scale(.99)}100%{opacity:1;transform:translateY(0) scale(1)}}
    .enter-anim{animation:fadeSlideIn 260ms ease-out both}
    .drag-handle{cursor:grab;user-select:none;color:#9ca3af}
    .drag-handle:active{cursor:grabbing}
    .drop-indicator{height:10px;margin:-6px 0 6px 0;border-radius:6px}
    /* swipe-card */
    .swipe-shell{position:relative}
    .swipe-bg{position:absolute;inset:0;border-radius:16px;background:#fee2e2;color:#991b1b;display:flex;align-items:center;justify-content:flex-end;padding-right:14px}
    .swipe-fg{position:relative;will-change:transform;touch-action:pan-y}
    /* meny + snackbar */
    .menu{position:absolute;top:.25rem;right:.25rem}
    .menu-panel{position:absolute;top:28px;right:0;background:#fff;border:1px solid #e5e7eb;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.08);min-width:160px;z-index:20}
    .menu-item{width:100%;text-align:left;background:#fff;border:0;padding:10px 12px;font-size:14px;color:#374151}
    .menu-item:hover{background:#f3f4f6}
    .snackbar{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#111827;color:#fff;padding:10px 14px;border-radius:12px;display:flex;align-items:center;gap:10px;box-shadow:0 10px 30px rgba(0,0,0,.2);z-index:50}
    .snackbar button{background:transparent;border:0;color:#93c5fd}
    .snackbar button:hover{color:#bfdbfe}
    /* tabs */
    .tabs-scroll{display:flex;gap:.5rem;overflow-x:auto;padding-bottom:.25rem}
    .tab{flex:0 0 auto;max-width:60vw;padding:.4rem .7rem;border-radius:9999px;border:1px solid #e5e7eb;background:#ffffff;color:#374151}
    .tab.active{background:#111827;color:#ffffff;border-color:#111827}
    .tab input{background:transparent;border:0;border-bottom:1px solid #cbd5e1}
  </style>
</head>
<body>
  <div id="root" class="min-h-screen flex flex-col items-center justify-center p-6"></div>

  <script type="text/babel" data-presets="react,env">
    const { useState, useEffect, useRef, useMemo } = React;
    const noSleep = new window.NoSleep();

    // helpers
    const uid = () => crypto.randomUUID?.() || String(Date.now()+Math.random());

    function App() {
      // tabs + migration from old single-list
      const [tabs, setTabs] = useState(() => {
        try {
          const stored = JSON.parse(localStorage.getItem("todo-tabs-v1"));
          if (stored && Array.isArray(stored) && stored.length) return stored;
        } catch {}
        // migrate legacy items if present
        let legacy = [];
        try { legacy = JSON.parse(localStorage.getItem("todo-items-v1")) || []; } catch {}
        const first = { id: uid(), name: "min lista", items: legacy };
        return [first];
      });
      const [activeTabId, setActiveTabId] = useState(() => {
        const s = localStorage.getItem("todo-active-tab");
        return s || (Array.isArray(tabs) && tabs[0]?.id) || null;
      });

      // keep awake
      const [keepAwake, setKeepAwake] = useState(() => localStorage.getItem("todo-keep-awake") === "true");
      const [wakeLock, setWakeLock] = useState(null);
      const [awakeStrategy, setAwakeStrategy] = useState("off");

      // draft/search/filter
      const [draft, setDraft] = useState("");
      const [query, setQuery] = useState("");
      const [filter, setFilter] = useState("all");

      // dnd
      const [draggingId, setDraggingId] = useState(null);
      const [overId, setOverId] = useState(null);
      const [overPosition, setOverPosition] = useState("above");

      // ui focus etc
      const draftRef = useRef(null);
      const [inputGlow, setInputGlow] = useState(false);
      const [lastAddedId, setLastAddedId] = useState(null);
      const holdTimerRef = useRef(null);
      const HOLD_MS = 500;

      // rename tab
      const [renamingTabId, setRenamingTabId] = useState(null);
      const renameRef = useRef(null);

      // undo
      const [undo, setUndo] = useState(null);
      const undoTimer = useRef(null);

      // persist
      useEffect(() => {
        localStorage.setItem("todo-tabs-v1", JSON.stringify(tabs));
      }, [tabs]);
      useEffect(() => {
        if (activeTabId) localStorage.setItem("todo-active-tab", activeTabId);
      }, [activeTabId]);
      useEffect(() => { localStorage.setItem("todo-keep-awake", String(keepAwake)); }, [keepAwake]);

      // cleanup legacy key if we migrated
      useEffect(() => {
        try { localStorage.removeItem("todo-items-v1"); } catch {}
      }, []);

      // keep awake handling
      useEffect(() => { if (keepAwake) enableKeepAwake(); else disableKeepAwake(); return () => disableKeepAwake(); }, [keepAwake]);
      useEffect(() => {
        const onVis = async () => { if (document.visibilityState === "visible" && keepAwake) await enableKeepAwake(true); };
        document.addEventListener("visibilitychange", onVis);
        return () => document.removeEventListener("visibilitychange", onVis);
      }, [keepAwake]);

      async function enableKeepAwake(silent=false) {
        try {
          if ("wakeLock" in navigator && navigator.wakeLock?.request) {
            const lock = await navigator.wakeLock.request("screen");
            if (wakeLock?.release) { try { await wakeLock.release(); } catch(_){} }
            setWakeLock(lock); setAwakeStrategy("wakeLock");
            lock.addEventListener?.("release", () => {});
            return;
          }
        } catch (err) { if (!silent) console.log("wake lock fail:", err); }
        try { noSleep.enable(); setAwakeStrategy("noSleep"); }
        catch { setAwakeStrategy("off"); }
      }
      async function disableKeepAwake() {
        try { if (wakeLock?.release) await wakeLock.release(); } catch(_) {}
        setWakeLock(null);
        try { noSleep.disable(); } catch(_) {}
        setAwakeStrategy("off");
      }

      // helpers to get/set active tab
      const activeTab = useMemo(() => tabs.find(t => t.id === activeTabId) || tabs[0], [tabs, activeTabId]);

      // derived list for active tab
      const visible = useMemo(() => {
        const items = activeTab?.items || [];
        let v = items;
        if (filter === "active") v = v.filter(i => !i.done);
        if (filter === "done")   v = v.filter(i =>  i.done);
        if (query.trim()) {
          const q = query.trim().toLowerCase();
          v = v.filter(i => i.title.toLowerCase().includes(q));
        }
        return v;
      }, [activeTab, filter, query]);

      const remaining = (activeTab?.items || []).filter(i => !i.done).length;

      // actions (operate on active tab only)
      const updateActiveItems = (updater) => {
        setTabs(prev => prev.map(tab => {
          if (tab.id !== activeTab.id) return tab;
          const newItems = updater(tab.items || []);
          return { ...tab, items: newItems };
        }));
      };

      const addItem = () => {
        const title = draft.trim();
        if (!title) { focusDraft(true); return; }
        const id = uid();
        updateActiveItems(items => [...items, { id, title, done:false, created_at: Date.now() }]);
        setDraft("");
        setLastAddedId(id);
        setTimeout(() => setLastAddedId(null), 400);
        focusDraft();
      };

      const toggleItem = (id) => updateActiveItems(items => items.map(i => i.id === id ? {...i, done: !i.done} : i));
      const updateTitle = (id, title) => updateActiveItems(items => items.map(i => i.id === id ? {...i, title} : i));

      const deleteItem = (id) => {
        updateActiveItems(items => {
          const idx = items.findIndex(i => i.id === id);
          if (idx === -1) return items;
          const removed = items[idx];
          const next = items.slice(0, idx).concat(items.slice(idx+1));
          showUndo({ item: removed, index: idx, tabId: activeTab.id });
          return next;
        });
      };

      const clearDone = () => {
        const snapshot = activeTab?.items || [];
        const next = snapshot.filter(i => !i.done);
        if (snapshot.length !== next.length) showUndo({ item:null, index:null, batch:snapshot.filter(i=>i.done), tabId: activeTab.id });
        updateActiveItems(() => next);
      };

      function showUndo(payload){ clearTimeout(undoTimer.current); setUndo(payload); undoTimer.current=setTimeout(()=>setUndo(null),6000); }
      function performUndo(){
        clearTimeout(undoTimer.current);
        if (!undo) return;
        setTabs(prev => prev.map(tab => {
          if (tab.id !== undo.tabId) return tab;
          if (undo.batch) {
            return { ...tab, items: tab.items.concat(undo.batch) };
          } else {
            const base = tab.items.slice();
            const idx = Math.min(undo.index ?? base.length, base.length);
            base.splice(idx, 0, undo.item);
            return { ...tab, items: base };
          }
        }));
        setUndo(null);
      }

      function focusDraft(glow=false){
        requestAnimationFrame(()=>{ draftRef.current?.focus(); if(glow){ setInputGlow(true); setTimeout(()=>setInputGlow(false),450);} });
      }
      const onDraftKey = (e)=>{ if(e.key==="Enter"){ e.preventDefault(); addItem(); } };

      // ＋ handlers (tap = add new card; long-press = clear input)
      function onPlusPointerDown(){
        clearTimeout(holdTimerRef.current);
        holdTimerRef.current = setTimeout(()=>{
          setDraft("");
          focusDraft(true);
          try{ navigator.vibrate && navigator.vibrate(20); }catch(_){}
        }, HOLD_MS);
      }
      function cancelHold(){ clearTimeout(holdTimerRef.current); }
      function onPlusClick(){
        const title = (draft || "").trim() || "ny uppgift";
        const id = uid();
        updateActiveItems(items => [...items, { id, title, done:false, created_at: Date.now() }]);
        if ((draft || "").trim()) setDraft("");
        setLastAddedId(id);
        setTimeout(() => setLastAddedId(null), 400);
        focusDraft();
      }

      // dnd (on active list)
      function onDragStart(e, id){ setDraggingId(id); e.dataTransfer.effectAllowed="move"; try{ e.dataTransfer.setData("text/plain", id);}catch{} }
      function onDragOverRow(e, id){ e.preventDefault(); setOverId(id); const r=e.currentTarget.getBoundingClientRect(); const mid=r.top+r.height/2; setOverPosition(e.clientY<mid?"above":"below"); e.dataTransfer.dropEffect="move"; }
      function onDragLeaveRow(){ setOverId(null); }
      function onDropRow(e, id){ e.preventDefault(); if(!draggingId) return; reorder(draggingId, id, overPosition); cleanupDnD(); }
      function onDragEnd(){ cleanupDnD(); }
      function cleanupDnD(){ setDraggingId(null); setOverId(null); setOverPosition("above"); }
      function reorder(srcId, targetId, pos){
        updateActiveItems(items => {
          const srcIdx=items.findIndex(i=>i.id===srcId);
          const targetIdx=items.findIndex(i=>i.id===targetId);
          if(srcIdx===-1||targetIdx===-1) return items;
          const arr=items.slice();
          const [moved]=arr.splice(srcIdx,1);
          let insertIdx=targetIdx;
          if(pos==="below"&&srcIdx<targetIdx) insertIdx=targetIdx;
          if(pos==="above"&&srcIdx>targetIdx) insertIdx=targetIdx;
          if(pos==="below") insertIdx=Math.min(insertIdx+(srcIdx<targetIdx?0:1), arr.length);
          arr.splice(insertIdx,0,moved);
          return arr;
        });
      }

      // tabs actions
      const addTab = () => {
        const t = { id: uid(), name: "ny lista", items: [] };
        setTabs(prev => [...prev, t]);
        setActiveTabId(t.id);
        setRenamingTabId(t.id);
        setTimeout(()=>renameRef.current?.focus(), 0);
      };
      const renameTab = (id, name) => {
        setTabs(prev => prev.map(t => t.id===id ? {...t, name: (name||"").trim() || t.name} : t));
      };
      const deleteTab = (id) => {
        if (tabs.length <= 1) return; // minst en tab
        setTabs(prev => prev.filter(t => t.id !== id));
        if (activeTabId === id) {
          const next = tabs.find(t => t.id !== id);
          setActiveTabId(next?.id || null);
        }
      };

      return (
        <main className="max-w-md w-full space-y-6">
          <header className="text-center">
            <h1 className="text-3xl font-semibold mb-2">att göra</h1>
            <p className="text-stone-500 text-sm">flera listor, samma lugn</p>
          </header>

          {/* tabs bar */}
          <div className="bg-white border border-stone-200 rounded-2xl p-3 shadow-sm">
            <div className="tabs-scroll">
              {tabs.map(tab => {
                const active = tab.id === activeTab.id;
                return (
                  <div key={tab.id} className={`tab ${active?'active':''}`} onClick={()=>setActiveTabId(tab.id)}>
                    {renamingTabId===tab.id ? (
                      <input
                        ref={renameRef}
                        defaultValue={tab.name}
                        onBlur={(e)=>{ renameTab(tab.id, e.target.value); setRenamingTabId(null); }}
                        onKeyDown={(e)=>{ if(e.key==='Enter'){ e.preventDefault(); e.currentTarget.blur(); } }}
                        className="text-sm px-1"
                        aria-label="byt namn på lista"
                      />
                    ) : (
                      <div className="flex items-center gap-2">
                        <span className="truncate">{tab.name}</span>
                        {active && (
                          <button title="byt namn" className="icon-btn text-sm" onClick={(e)=>{ e.stopPropagation(); setRenamingTabId(tab.id); setTimeout(()=>renameRef.current?.focus(),0); }}>✎</button>
                        )}
                        {tabs.length>1 && active && (
                          <button title="ta bort lista" className="icon-btn text-sm" onClick={(e)=>{ e.stopPropagation(); deleteTab(tab.id); }}>×</button>
                        )}
                      </div>
                    )}
                  </div>
                );
              })}
              <button className="tab" title="ny lista" onClick={addTab}>＋ ny</button>
            </div>
          </div>

          {/* keep awake */}
          <div className="flex items-center justify-center gap-3 flex-wrap">
            <label className="flex items-center gap-2">
              <input type="checkbox" className="w-5 h-5 accent-stone-700 cursor-pointer"
                     checked={keepAwake} onChange={e=>setKeepAwake(e.target.checked)} />
              <span className="text-stone-600 text-sm select-none">håll skärmen vaken</span>
            </label>
          </div>
          <p className="text-center text-xs text-stone-500 -mt-2">
            status: {awakeStrategy==="wakeLock"?"skärmlås aktivt (wake lock)":awakeStrategy==="noSleep"?"skärmlås via nosleep":"av"}
          </p>

          {/* add new */}
          <div className="bg-white border border-stone-200 rounded-2xl p-4 shadow-sm">
            <div className="relative">
              <input
                ref={draftRef}
                type="text"
                value={draft}
                onChange={(e)=>setDraft(e.target.value)}
                onKeyDown={onDraftKey}
                placeholder={`vad är nästa? (${activeTab?.name||'lista'})`}
                className={`w-full bg-transparent border-b border-stone-300 focus:border-stone-600 transition p-2 text-lg ${inputGlow?'glow':''}`}
              />
              {draft && <button className="input-clear" aria-label="rensa" onClick={()=>setDraft("")}>×</button>}
            </div>
            <div className="mt-3 flex items-center gap-2">
              <button onClick={addItem} className="px-3 py-2 rounded-lg bg-stone-900 text-white text-sm hover:bg-stone-800 active:scale-95 transition">lägg till</button>
              <input type="search" value={query} onChange={(e)=>setQuery(e.target.value)} placeholder="sök…" className="flex-1 bg-stone-50 border border-stone-200 rounded-lg px-3 py-2 text-sm"/>
            </div>
          </div>

          {/* filter */}
          <div className="flex items-center justify-between text-sm">
            <div className="text-stone-600">{remaining} kvar</div>
            <div className="flex gap-2">
              <button className={`px-2 py-1 rounded ${filter==='all'?'bg-stone-900 text-white':'text-stone-700 border border-stone-300'}`} onClick={()=>setFilter('all')}>alla</button>
              <button className={`px-2 py-1 rounded ${filter==='active'?'bg-stone-900 text-white':'text-stone-700 border border-stone-300'}`} onClick={()=>setFilter('active')}>aktiva</button>
              <button className={`px-2 py-1 rounded ${filter==='done'?'bg-stone-900 text-white':'text-stone-700 border border-stone-300'}`} onClick={()=>setFilter('done')}>klara</button>
            </div>
          </div>

          {/* list */}
          <ul className="space-y-2">
            {visible.map(item => (
              <SwipeableDraggableItem
                key={item.id}
                item={item}
                isDragging={draggingId === item.id}
                isOver={overId === item.id}
                overPosition={overId === item.id ? overPosition : null}
                lastAddedId={lastAddedId}
                onDragStart={(e)=>onDragStart(e, item.id)}
                onDragOver={(e)=>onDragOverRow(e, item.id)}
                onDragLeave={onDragLeaveRow}
                onDrop={(e)=>onDropRow(e, item.id)}
                onDragEnd={onDragEnd}
                onToggle={()=>toggleItem(item.id)}
                onDelete={()=>deleteItem(item.id)}
                onCommit={(title)=>updateTitle(item.id, title)}
              />
            ))}
          </ul>

          {/* bulk actions – centrerad grupp */}
          <div className="pt-4 mt-4 border-t border-stone-200 flex flex-col items-center gap-2">
            <div className="plus-wrap" onPointerDown={onPlusPointerDown} onPointerUp={cancelHold} onPointerLeave={cancelHold} onPointerCancel={cancelHold}>
              <button className="plus-btn" onClick={onPlusClick} aria-label="Ny uppgift">＋</button>
            </div>
            <button className="text-stone-500 text-sm hover:text-stone-800 transition" onClick={clearDone}>rensa klara</button>
          </div>

          <footer className="text-center text-xs text-stone-400 pt-4 pb-2">gjord med ♥ i sverige</footer>

          {/* undo snackbar */}
          {undo && (
            <div className="snackbar" role="status" aria-live="polite">
              <span>{undo.batch ? `${undo.batch.length} uppgifter borttagna` : `uppgift borttagen`}</span>
              <button onClick={performUndo} aria-label="Ångra">ångra</button>
            </div>
          )}
        </main>
      );
    }

    function SwipeableDraggableItem({
      item, isDragging, isOver, overPosition, lastAddedId,
      onDragStart, onDragOver, onDragLeave, onDrop, onDragEnd,
      onToggle, onDelete, onCommit
    }) {
      const { useState, useEffect, useRef } = React;
      const [localTitle, setLocalTitle] = useState(item.title);
      const [menuOpen, setMenuOpen] = useState(false);
      const inputRef = useRef(null);
      const menuRef = useRef(null);

      // swipe state
      const shellRef = useRef(null);
      const fgRef = useRef(null);
      const startX = useRef(0);
      const currentX = useRef(0);
      const draggingSwipe = useRef(false);
      const threshold = 80; // px
      const maxSlide = 140;

      useEffect(() => { setLocalTitle(item.title); }, [item.title]);

      // stäng meny vid klick utanför
      useEffect(() => {
        const onDoc = (e) => { if (menuOpen && menuRef.current && !menuRef.current.contains(e.target)) setMenuOpen(false); };
        document.addEventListener('click', onDoc);
        return () => document.removeEventListener('click', onDoc);
      }, [menuOpen]);

      const commit = () => onCommit((localTitle||"").trim() || item.title);
      const onKeyDown = (e) => { if (e.key === "Enter") { e.preventDefault(); commit(); requestAnimationFrame(()=>inputRef.current?.focus()); } };
      const enterClass = item.id === lastAddedId ? 'enter-anim' : '';

      // swipe (touch/pointer)
      function onPointerDown(e){
        if (e.pointerType === 'mouse') return; // undvik konflikt med dnd
        draggingSwipe.current = true;
        startX.current = e.clientX;
        currentX.current = 0;
        fgRef.current.style.transition = 'none';
        fgRef.current.setPointerCapture?.(e.pointerId);
      }
      function onPointerMove(e){
        if (!draggingSwipe.current) return;
        const dx = e.clientX - startX.current;
        const tx = Math.max(-maxSlide, Math.min(0, dx)); // bara vänster
        currentX.current = tx;
        fgRef.current.style.transform = `translateX(${tx}px)`;
        shellRef.current.querySelector('.swipe-bg').style.opacity = Math.min(1, Math.abs(tx)/threshold);
      }
      function onPointerUp(e){
        if (!draggingSwipe.current) return;
        draggingSwipe.current = false;
        fgRef.current.releasePointerCapture?.(e.pointerId);
        fgRef.current.style.transition = 'transform 180ms ease';
        if (currentX.current <= -threshold){
          fgRef.current.style.transform = `translateX(-${maxSlide}px)`;
          setTimeout(()=>onDelete(), 140);
        } else {
          fgRef.current.style.transform = 'translateX(0)';
          shellRef.current.querySelector('.swipe-bg').style.opacity = 0;
        }
      }
      function onPointerCancel(e){ onPointerUp(e); }

      return (
        <li className={`swipe-shell ${enterClass}`} ref={shellRef}>
          <div className="swipe-bg" style={{opacity:0}} aria-hidden="true">ta bort</div>

          <div
            ref={fgRef}
            className={`swipe-fg bg-white border rounded-2xl p-4 shadow-sm transition ${isDragging ? 'opacity-60 border-stone-300' : 'border-stone-200'}`}
            draggable
            onDragStart={onDragStart}
            onDragOver={onDragOver}
            onDragLeave={onDragLeave}
            onDrop={onDrop}
            onDragEnd={onDragEnd}
            onPointerDown={onPointerDown}
            onPointerMove={onPointerMove}
            onPointerUp={onPointerUp}
            onPointerCancel={onPointerCancel}
          >
            {/* drop-indikator ovanför raden */}
            {isOver && overPosition === "above" && <div className="drop-indicator bg-stone-800/20 mb-2"></div>}

            <div className="flex items-start gap-3 relative">
              <span className="drag-handle text-xl select-none" title="Dra för att flytta" aria-hidden="true">≡</span>

              <input id={`chk-${item.id}`} type="checkbox" checked={item.done} onChange={onToggle} className="mt-1 w-5 h-5 accent-stone-700 cursor-pointer"/>

              <div className="flex-1">
                <div className="relative">
                  <input
                    ref={inputRef}
                    type="text"
                    value={localTitle}
                    onChange={(e)=>setLocalTitle(e.target.value)}
                    onBlur={commit}
                    onKeyDown={onKeyDown}
                    className={`w-full bg-transparent border-b p-1 pr-6 transition ${item.done ? 'text-stone-400 line-through border-stone-200' : 'border-stone-300 focus:border-stone-600'}`}
                  />
                  {localTitle && <button className="input-clear" aria-label="rensa fält" onClick={()=>{ setLocalTitle(""); requestAnimationFrame(()=>inputRef.current?.focus()); }}>×</button>}
                </div>
                <div className="text-xs text-stone-400 mt-1">
                  {new Date(item.created_at).toLocaleDateString('sv-SE', { year:'numeric', month:'short', day:'numeric' })}
                </div>
              </div>

              {/* ⋯ meny kvar */}
              <div className="menu" ref={menuRef}>
                <button className="icon-btn text-xl" aria-haspopup="menu" aria-expanded={menuOpen?'true':'false'} onClick={()=>setMenuOpen(v=>!v)} title="Alternativ">⋯</button>
                {menuOpen && (
                  <div className="menu-panel" role="menu">
                    <button className="menu-item" role="menuitem" onClick={()=>{ setMenuOpen(false); onDelete(); }}>ta bort</button>
                  </div>
                )}
              </div>
            </div>

            {/* drop-indikator under raden */}
            {isOver && overPosition === "below" && <div className="drop-indicator bg-stone-800/20 mt-2"></div>}
          </div>
        </li>
      );
    }

    ReactDOM.render(<App />, document.getElementById("root"));
  </script>
</body>
</html>